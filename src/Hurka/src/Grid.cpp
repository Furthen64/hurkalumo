#include "Grid.hpp"



/// //////////////////////////////////////////////
/// Grid           cr 2018-02-22
// The grid follows the static grid size of 64 x 64 px


// (-+)
Grid::Grid(int _height, int _width)
{
    width = _width;
    height = _height;




    texture.loadFromFile(getFullUri("data\\textures\\GRID1.png"));
    sprite = Sprite(texture);



    textureSelected.loadFromFile(getFullUri("data\\textures\\GRID_SELECTED.png"));
    spriteSelected = Sprite(textureSelected);

    // Load font
    if (!font.loadFromFile( getFullUri("data\\fonts\\consola.ttf")))
    {
        std::cout << "ERROR " << cn << " could not load font.\n";
    }


}


// (--)
void Grid::draw( RenderTarget& rt, HPos *viewHPos)
{
    int gx = 0;
    int gy = 0;
    int wx = 0;
    int wy = 0;

    Vector2f wPos = Vector2f(); // SFML specific...


    /*Vector2f firstGPos = Vector2f();        // Game position of the first grid cell
    Vector2f firstWPos = Vector2f();        // Window position of the first grid cell

    bool once = false;

    */


    for(int M= 0; M<height; M++){
        for(int N= 0; N < width; N++) {

            gx = convert_iso_to_gpix_x(M,N, GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT,0);
            gy = convert_iso_to_gpix_y(M,N, GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT,0);

  /*          if(!once)
            {
                firstGPos.x = gx;
                firstGPos.y = gy;
            }
*/
            wx = gx + viewHPos->gpix_x;
            wy = gy + viewHPos->gpix_y;

/*            if(!once) {
                firstWPos.x = wx;
                firstWPos.y = wy;
                once = true;
            }
*/

            wPos.x = wx;
            wPos.y = wy;

            sprite.setPosition(wPos);
            rt.draw(sprite);

        }

    }


    // Draw the selected grid that should be more visible
    gx = convert_iso_to_gpix_x(selected_iso_pos.y, selected_iso_pos.x, GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT, 0);
    gy = convert_iso_to_gpix_y(selected_iso_pos.y, selected_iso_pos.x, GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT, 0);

    wx = gx+ viewHPos->gpix_x;
    wy = gy+ viewHPos->gpix_y;

    wPos.x = wx;
    wPos.y = wy;

    spriteSelected.setPosition(wPos);
    rt.draw(spriteSelected);



    /// Also draw coordinates in text for the top one
    /*
    text.setFont(font);

    std::stringstream sstm;
    sstm << "GPOS(" << firstGPos.y << ", " << firstGPos.x << ")\n";
    sstm << "WPOS(" << firstWPos.y << ", " << firstWPos.x << ")\n";

    std::string txtStr = sstm.str();
    text.setString(txtStr );
    text.setCharacterSize(12);
    text.setFillColor(sf::Color::White);


    // inside the main loop, between window.clear() and window.display()
    text.setPosition(firstWPos);
    rt.draw(text);
*/


}



// Hm... The Pos coming in have pix_positions..
//these pixel positions could have been generated by aa tall house block with height=64, while
//the grid is =32 so... we get a faulty gpix_x and gpix_y ... should really re-compute it if we need it here
// Beta material!

void Grid::setVisible(HPos *_pos)
{
    if(_pos == nullptr) {
            std::cout << "WARNING: setVisible: _pos is nullptr!\n";
            return ;
    }
    drawSelectedGrid = true;

    selected_iso_pos.y = _pos->abs_iso_y;
    selected_iso_pos.x = _pos->abs_iso_x;

    selected_pix_pos.y = _pos->gpix_y;
    selected_pix_pos.x = _pos->gpix_x;
}



// HPOSDELETE
/*
void Grid::setVisible(Vector2f iso_pos)
{
    drawSelectedGrid = true;


    selected_iso_pos = iso_pos;

    selected_pix_pos.x = convert_iso_to_gpix_x(iso_pos.y, iso_pos.x, GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT, 0);
    selected_pix_pos.y = convert_iso_to_gpix_y(iso_pos.y, iso_pos.x, GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT, 0 );



 //   std::cout << "Visible grid position: " << selected_pix_pos.x << " , " << selected_pix_pos.y << "\n";
}

*/





void Grid::hideVisible()
{
    drawSelectedGrid = false;
}






//här var du och pseudokodade nästan iväg.. utan att ttesta findTile()



// CR7 - Work in progress 2018-06-02






// Uses internal findTile() function

// (--)
HPos *Grid::findTile(HRect *entireGameBoard, HPos *searchPos, std::string ind, RenderTarget& rt, HPos *viewHPos)
{
    HRect *relRect = new HRect(
                                    entireGameBoard->absStart,
                                    entireGameBoard->rows,
                                    entireGameBoard->cols,
                                    entireGameBoard->heightPx,
                                    entireGameBoard->widthPx);
    std::cout << "\nfindTile()-----------------------------\n";

    std::cout << " - relRect = " << relRect->absToString() << "\n";

    if(searchPos == nullptr) {
        std::cout << "ERROR " << cn << " searchpos is nullptr\n";
        return nullptr;
    }
    std::cout << " - searchpos= " << searchPos->gpix_y << "," << searchPos->gpix_x << "\n";

    return findTile(entireGameBoard, relRect, searchPos, ind, 0, rt, viewHPos);

}














/// \brief Given a searchpos with gpix values set, find an iso inside a hmatrix
/// \param entireGameBoard
/// \param relRect A smaller than entireGameBoard rectangle, used in a divide n conquer manner
/// \param searchPos Gpix values of search position
// RECURSIVE
// (--) Test     Does not work yet
HPos *Grid::findTile(HRect *entireGameboard, HRect *relRect, HPos *searchPos, std::string ind, int counter, RenderTarget& rt, HPos *viewHPos)
{
int debugLevel = 1; // FIXME


    if(counter > 20) {
        std::cout << "WARNING: findTile reached limit, counter= " << counter << "\n";
        return nullptr;
    }

    if(entireGameboard == nullptr) {
        std::cout << "ERROR " << cn << " findTile() entireGameBoard is nullptr\n";
        return nullptr;
    }


    if(relRect == nullptr) {
        std::cout << "ERROR " << cn << " findTile() relRect is nullptr\n";
        return nullptr;
    }

    if(searchPos == nullptr) {
        std::cout << "ERROR " << cn << " findTile() searchPos is nullptr\n";
        return nullptr;
    }



    HPos *retpos = nullptr;


	if(debugLevel >=1) {
        std::cout << "\n\n";
        std::cout << ind << "findTile()---------------------------\n";
        std::cout << ind << " - relrect: " << relRect->absToString() << "\n";
	}


    std::cout << ind <<  "- insideXpixels: ";

    if( !relRect->insideXPixles( searchPos ) ) {
        std::cout << " No.\n";
        return nullptr;
    }
    std::cout << " Yes.\n";




    std::cout << ind <<  "- insideYpixels: ";
    if ( !relRect->insideYPixles( searchPos ) ) {
            std::cout << " No.\n";
        return nullptr;
    }
    std::cout << " Yes.\n";




    /// OK - it CAN be inside here, lets check if we need to do bruteforce or just "divide n conquer" again


	int nrTiles = relRect->nrTiles();
	std::cout << ind << "- nrTiles: " << nrTiles << "\n";



	if(nrTiles <= 16) {
		return bruteForceFindTile( entireGameboard, relRect, searchPos, ind, rt, viewHPos );                // RECURSION END
	}





	/// Approach it the smart way

	// Divide the submatrix into four squares



    int rows = relRect->rows;
    int cols = relRect->cols;



    int halfRows1 = -1;
    int halfRows2 = -1;
    int halfCols1 = -1;
    int halfCols2 = -1;



    // figure out how to divide the four squares, if rows n cols are not evenly divided by 2

    if(rows/2%2==0) {
        halfRows1 = rows/2;
        halfRows2 = halfRows1  -1;               // We need -1 because the last position is not 20 its 19, because 0->19 is 20 elements hope that makes sense.
    } else {
        halfRows1 = (rows-1)/2;
        halfRows2 = rows - halfRows1  -1;        // same here
    }


     if(cols/2%2==0) {
        halfCols1 = cols/2;
        halfCols2 = halfCols1   -1;              // same here
    } else {
        halfCols1 = (cols-1)/2;
        halfCols2 = rows - halfCols1    -1;      // same here
    }


/*
    if(debugLevel >=2) {

        std::cout << "\n";
        std::cout << ind << "Divide the submatrix into four squares\n";

        std::cout << ind << " - halfRows1=" << halfRows1 << "\n";
        std::cout << ind << " - halfCols1=" << halfCols1 << "\n";
        std::cout << ind << " - halfRows2=" << halfRows2 << "\n";
        std::cout << ind << " - halfCols2=" << halfCols2 << "\n";


	}

*/

	HRect *sq0, *sq1, *sq2, *sq3;






	// SQUARE 0

	int fromY= relRect->absStart->abs_iso_y;    // Are these VALID, are the abs_isos set correctlt?
	int fromX = relRect->absStart->abs_iso_x;
	int toY = fromY + halfRows1;
	int toX = fromX + halfCols1;

	//sq0 = new HRect( fromY,         fromX,               toY,    toX, 32,64);

	sq0 = new HRect( new HPos(fromY, fromX,USE_ISO),
	                 new HPos(toY, toX, USE_ISO));







	fromY = fromY;         // Keep it as is
	fromX = toX +1;        // Continue from previous square, but add 1 so we dont overlap and run same tiles again
	toY = toY;             // Keep it as is
    toX = toX + halfCols2;
	//sq1 = new HRect( fromY,         fromX,               toY,    toX, 32,64);

    sq1 = new HRect( new HPos(fromY, fromX,USE_ISO),
	                 new HPos(toY, toX, USE_ISO));





	// Beginning on a new line

	fromY = halfRows1 + 1;  // Continue from the previous squares, but add 1 so we dont overlap and run same tiles again
	fromX = relRect->absStart->abs_iso_x;
	toY = toY + halfRows2;                      // Add the other half
	toX = halfCols1;

    //sq2 = new HRect( fromY,         fromX,               toY,    toX, 32,64);

    sq2 = new HRect( new HPos(fromY, fromX,USE_ISO),
	                 new HPos(toY, toX, USE_ISO));






	fromY = fromY;                   // Keep as it is
	fromX = fromX + halfCols1 + 1 ;  //
    toY = toY;                      // Keep as it is
    toX = toX + halfCols2;          // Add the other half


    //sq3 = new HRect( fromY,         fromX,               toY,    toX, 32,64);

    sq3 = new HRect( new HPos(fromY, fromX,USE_ISO),
	                 new HPos(toY, toX, USE_ISO));




	if(debugLevel >=1) {

        std::cout << "\n";

        std::cout << ind << "We divide up current relrect to these new 4 squares:\n";

        sq0->dump("  ");
        sq1->dump("  ");
        sq2->dump("  ");
        sq3->dump("  ");

	}



	/// Enter each square and look for the grid

	if(debugLevel >=2) {std::cout << " entering sq0: \n"; }
	retpos = findTile(entireGameboard, sq0, searchPos, ind ,++counter , rt, viewHPos);
	if(retpos != nullptr) { return retpos; }

    if(debugLevel >=2) {std::cout << " entering sq1: \n"; }
    retpos = findTile(entireGameboard, sq1, searchPos, ind, ++counter, rt , viewHPos);
    if(retpos != nullptr) { return retpos; }


    if(debugLevel >=2) {std::cout << " entering sq2: \n"; }
    retpos = findTile(entireGameboard, sq2, searchPos, ind ,++counter , rt, viewHPos );
    if(retpos != nullptr) { return retpos; }

    if(debugLevel >=2) {std::cout << " entering sq3: \n"; }
    retpos = findTile(entireGameboard, sq3, searchPos, ind  ,++counter, rt, viewHPos );
    if(retpos != nullptr) { return retpos; }






    return retpos;

}


/// \brief internal function used by "findTile()" to go pixelline by line for every tile inside a relative rect
/// \param entireGameBoard
/// \param relRect A smaller than entireGameBoard rectangle, used in a divide n conquer manner
/// \param searchPos Gpix values of search position
// (--) Test
HPos *Grid::bruteForceFindTile(HRect *entireGameboard, HRect *relRect, HPos *searchPos, std::string ind, RenderTarget &rt, HPos *viewHPos)
{

    std::cout << "\n";
    std::cout << ind <<  "bruteForecFindTile()------------\n";


// FIXME remove all graphical debug nonsens
    sf::RenderWindow *rw;
    rw = (sf::RenderWindow*) &rt;


    HPos *isopos = nullptr;


    // Generate iso pos for all the tiles inside the relrect
    // and check if we're inside it

    // Make sure you use ABSOLUTE positioning, considering the gpix
    // of the searchpos is ABSOLUTE positioned....

    // So DONT set Y=0 and X=0 and go from there
    // You have to figure out the starting position and use the ROWS and COLS
    // of the RELRECT











    // ALSO

    // Check for Y !!!
    // SHEESH.


    int currentY = -1;


    for(int Y = relRect->absStart->abs_iso_y; Y < (relRect->absStart->abs_iso_y+relRect->rows); Y++)
    {

        for(int X = relRect->absStart->abs_iso_x; X < (relRect->absStart->abs_iso_x+relRect->cols); X++)
        {


            // Current Tile:
            isopos    = new HPos(Y,X,USE_ISO);
            std::cout << ind << " - Current Tile: " << isopos->absToString() << "\n";

            // Figure out what Y pixelliune we're at
            currentY = Grid::convert_iso_to_gpix_y(isopos->abs_iso_y, isopos->abs_iso_x, GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT, 0);



            // Draw a White rectangle around the square that is our current tile
            sf::RectangleShape currIsoPosRect(sf::Vector2f(GRID_TEXTURE_WIDTH, GRID_TEXTURE_HEIGHT));
            currIsoPosRect.setPosition(sf::Vector2f( isopos->gpix_x + viewHPos->gpix_x, isopos->gpix_y + viewHPos->gpix_y));
            currIsoPosRect.setOutlineThickness(1.0f);
            currIsoPosRect.setOutlineColor(sf::Color(255,255,255));
            currIsoPosRect.setFillColor(sf::Color(0,0,0));

            rt.draw(currIsoPosRect);





            // Rough check if insideXpixel span

            // Is this the the way to do it? Shouldnt it check against the hrect bounds? isopos is not a rect, so it does not have those. It has gpixx and we know the grid texture width



            if( isopos->gpix_x < searchPos->gpix_x  && searchPos->gpix_x < (isopos->gpix_x + GRID_TEXTURE_WIDTH) ) {
                std::cout << ind << "   - inside x span.\n";
            } else {
                continue; // No reason to look into pixel by pixel ... Next!
            }





            // Rough check if insideYpixel span


            if( isopos->gpix_y < searchPos->gpix_y  && searchPos->gpix_y < (isopos->gpix_y + GRID_TEXTURE_HEIGHT) ) {
                std::cout << ind << "   - inside y span.\n";
            } else {
                continue; // Next!
            }







            ///
            /// Now compare if its inside here, use that nice... pixel by pixel row you did on paper
            ///





            //const int GRID_TEXTURE_HEIGHT = 32;
            //const int GRID_TEXTURE_WIDTH  = 64;




            //                      ##                  xwidth=2            xoffset=64/2 - width/2
            //                    ##$$##                xwidth=6    (+4)    xoffset=64/2 - width/2
            //                  ##$$##$$##              xwidth=10   (+4)
            //                ##$$##$$##$$##


            // Loop1 going downwards from a pointy tip


            int xwidth = 2;
            int xoffset = GRID_TEXTURE_WIDTH/2;     // =32 pixels
            xoffset += isopos->gpix_x;              // add the position of the Tile we're currently looking at

            int fromX;
            int toX;


            // Debuggies
            int drawFromX;
            int drawFromY;


            fromX = xoffset;
            toX = fromX + xwidth;

            for(int y = 0; y < (GRID_TEXTURE_HEIGHT/2); y++)
            {



                // Along the x-pixels we're looking, draw a red line
                sf::RectangleShape searchLine(sf::Vector2f(xwidth, 1));

                drawFromX = fromX + viewHPos->gpix_x;
                drawFromY = currentY + viewHPos->gpix_y;


                searchLine.setPosition(sf::Vector2f( drawFromX,
                                                     drawFromY));



                searchLine.setOutlineThickness(1.0f);
                searchLine.setOutlineColor(sf::Color(255,0,0));
                searchLine.setFillColor(sf::Color(255,0,0));

                rt.draw(searchLine);



                if( fromX < searchPos->gpix_x  && searchPos->gpix_x < toX ) {
                    if(currentY == searchPos->gpix_y) {

                        // inside?
                        std::cout << ind << " - - -  Eureka!  we are inside " << fromX << " - ( " << searchPos->gpix_x << " ) - " << toX << "\n";
                        rw->display();
                        return isopos;
                    }
                }

                // No luck, please go down one pixelline and increase Xwidth and adjust fromX
                xwidth+=4;


                // Adjust fromX
                fromX = isopos->gpix_x;
                fromX += GRID_TEXTURE_WIDTH/2;
                fromX -= (int)floor(xwidth/2);

                // Adjust toX
                toX = fromX + xwidth;

                // Next line? increment currentY
                currentY++;

            }



            //
            //                ##$$##$$##$$##
            //                  ##$$##$$##
            //                    ##$$##
            //                      ##



            xwidth-=4;  // Just step back a bit from the last one,
            xoffset = GRID_TEXTURE_WIDTH/2 - (int)floor(xwidth/2); // and recalc this one...
            xoffset += isopos->gpix_x;  // add the position of the Tile we're currently looking at


            // Now we're good to go. Do the same thing in loop2 but reverse the operations
            // on xwidth and xoffset for every line:


            fromX = xoffset;


            for(int y = (GRID_TEXTURE_HEIGHT/2); y < GRID_TEXTURE_HEIGHT; y++)
            {

                // Setup from and to

                toX = fromX + xwidth;






                // Along the x-pixels we're looking, draw a orange line
                sf::RectangleShape searchLine(sf::Vector2f(xwidth, 1));

                drawFromX = fromX + viewHPos->gpix_x;
                drawFromY = currentY + viewHPos->gpix_y;


                searchLine.setPosition(sf::Vector2f( drawFromX,
                                                     drawFromY));



                searchLine.setOutlineThickness(1.0f);
                searchLine.setOutlineColor(sf::Color(255,200,0));
                searchLine.setFillColor(sf::Color(255,200,0));

                rt.draw(searchLine);







                if( fromX < searchPos->gpix_x  && searchPos->gpix_x < toX ) {

                    if(currentY == searchPos->gpix_y) {



                        // inside?
                        std::cout << ind << " - - -  Eureka!  we are inside " << fromX << " - ( " << searchPos->gpix_x << " ) - " << toX << "\n";
                        rw->display();
                        return isopos;

                    }
                }

                // No luck, please go down one pixelline and decrease Xwidth and adjust xoffset


                xwidth-=4;

                fromX = isopos->gpix_x;
                fromX += GRID_TEXTURE_WIDTH/2;
                fromX -= (int)floor(xwidth/2);      // Does this even work? Correct thinking?


                // Next line? increment currentY
                currentY++;

            }


            rw->display();


        }  // for x   iso tiles

    } // for y        iso tiles



    rw->display();


    return nullptr;
}


